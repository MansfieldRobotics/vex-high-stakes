# ---------------------------------------------------------------------------- #
#                                                                              #
#   Module:       main.py                                                      #
#   Author:       MHS Robotics Team                                            #
#   Created:      11/15/2024, 2:23:12 PM                                       #
#   Description:  V5 project                                                   #
#                                                                              #
# ---------------------------------------------------------------------------- #
from vex import *
from vex import Optical


flip = False



# Brain should be defined by default
brain = Brain()
lMotor1 = Motor(Ports.PORT17, GearSetting.RATIO_36_1, flip)
rMotor1 = Motor(Ports.PORT19, GearSetting.RATIO_36_1, not flip)
lMotor2 = Motor(Ports.PORT13, GearSetting.RATIO_36_1, flip)
rMotor2 = Motor(Ports.PORT20, GearSetting.RATIO_36_1, not flip)
lMotor = MotorGroup(lMotor1,lMotor2)
rMotor = MotorGroup(rMotor1,rMotor2)
dTrain = DriveTrain(lMotor, rMotor, wheelTravel=300, trackWidth=300, wheelBase=170, units=INCHES)
cont = Controller()




# Initialize inertial sensor
inertial = Inertial(Ports.PORT15)  # Make sure to use the correct port
inertial.calibrate()
wait(2, SECONDS)  # Allow time for calibration




def rotatePID(direction, deg, kp=1, ki=0, kd=0):
      target_angle = deg if direction == 'left' else -deg
      lasterror = 0
      while True:
          current_angle = inertial.heading(DEGREES)
          error = target_angle - current_angle
          PID_output = PIDMath(error, lasterror, kp, ki, kd)
          lasterror = error
          final_velocity = apply_deadband(PID_output)
          lMotor.set_velocity(final_velocity if direction == 'left' else -final_velocity, PERCENT)
          rMotor.set_velocity(-final_velocity if direction == 'left' else final_velocity, PERCENT)
          lMotor.spin(FORWARD)
          rMotor.spin(FORWARD)
          if abs(error) < 1:  # Stop condition when close to target
              lMotor.stop()
              rMotor.stop()
              break
          wait(10, MSEC)





def apply_deadband(value, threshold=5):
 if abs(value) < threshold:
     return 0
 return value







def square_input(value):
 return value * value if value > 0 else -(value * value)






def PIDMath(error, lasterror, kp=1.0, ki=0.0, kd=0.0):
 # PID math function that we use for PID control
 Proportional = error * kp  # Proportional value
 Integral = (error + lasterror) * ki  # Integral math
 Derivative = (error - lasterror) * kd  # Derivative Math
 PID = Proportional + Integral + Derivative  # Final PID value calculation
 return PID  # return the final value






def calculate_motor_velocities(forward_velocity, turn_velocity, lasterror_l, lasterror_r, kp=0.05, ki=0.5, kd=0.05):
 # Calculate target velocities
 target_velocity_l = forward_velocity - turn_velocity
 target_velocity_r = forward_velocity + turn_velocity








 # Read actual velocities
 actual_velocity_l = lMotor.velocity(PERCENT)
 actual_velocity_r = rMotor.velocity(PERCENT)








 # Calculate errors
 error_l = target_velocity_l - actual_velocity_l
 error_r = target_velocity_r - actual_velocity_r








 # Calculate PID outputs
 PID_output_l = PIDMath(error_l, lasterror_l, kp, ki, kd)
 PID_output_r = PIDMath(error_r, lasterror_r, kp, ki, kd)








 # Update last errors
 lasterror_l = error_l
 lasterror_r = error_r








 # Apply deadband after PID calculation
 final_velocity_l = apply_deadband(target_velocity_l + PID_output_l)
 final_velocity_r = apply_deadband(target_velocity_r + PID_output_r)








 return final_velocity_l, final_velocity_r, lasterror_l, lasterror_r








def userDrive():

     
   # Forward and backward movement with axis 4
   forward_velocity = apply_deadband(square_input(cont.axis3.position()))
   # Turning movement with axis 3
   turn_velocity = apply_deadband(square_input(cont.axis1.position()))



   lasterror_l = 0
   lasterror_r = 0


   # Calculate motor velocities
   final_velocity_l, final_velocity_r, lasterror_l, lasterror_r = calculate_motor_velocities(forward_velocity, turn_velocity, lasterror_l, lasterror_r, .75, .1, .1)


   # Set motor velocities
   lMotor.set_velocity(final_velocity_l, PERCENT)
   rMotor.set_velocity(final_velocity_r, PERCENT)


   # Spin motors
   lMotor.spin(FORWARD)
   rMotor.spin(FORWARD)






def pre_autonomous():
   # actions to do when the program starts
   brain.screen.clear_screen()
   brain.screen.print("pre auton code")
   wait(1, SECONDS)




def autonomous():
   brain.screen.clear_screen()
   brain.screen.print("autonomous code")
   # place automonous code here
   dTrain.drive_for(REVERSE,45,DistanceUnits.IN)





def user_control():
   brain.screen.clear_screen()
   # place driver control in this while loop
   while True:
       userDrive()
       wait(10, MSEC)




# create competition instance
comp = Competition(user_control, autonomous)
pre_autonomous()


